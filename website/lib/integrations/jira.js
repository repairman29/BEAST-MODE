/**
 * Jira Integration
 * 
 * Creates and updates Jira issues based on quality findings
 */

// Try to require logger, fallback to console if not available
let createLogger;
try {
  const loggerModule = require('../utils/logger');
  createLogger = loggerModule.createLogger || loggerModule.default?.createLogger || loggerModule;
} catch (e) {
  // Fallback logger
  createLogger = (name) => ({
    info: (...args) => console.log(`[${name}]`, ...args),
    warn: (...args) => console.warn(`[${name}]`, ...args),
    error: (...args) => console.error(`[${name}]`, ...args),
    debug: (...args) => console.debug(`[${name}]`, ...args),
  });
}
const log = createLogger('JiraIntegration');

class JiraIntegration {
  constructor() {
    this.connections = new Map(); // userId -> connection config
    this.issues = new Map(); // issueId -> issue data
  }

  /**
   * Connect Jira account
   */
  connect(userId, config) {
    const connection = {
      userId,
      jiraUrl: config.jiraUrl,
      email: config.email,
      apiToken: config.apiToken,
      projectKey: config.projectKey,
      connectedAt: new Date().toISOString()
    };

    this.connections.set(userId, connection);
    log.info(`Jira connected: ${userId} -> ${config.jiraUrl}`);
    return connection;
  }

  /**
   * Create Jira issue from quality finding
   */
  async createIssue(userId, qualityFinding) {
    const connection = this.connections.get(userId);
    if (!connection) {
      throw new Error(`Jira not connected for user: ${userId}`);
    }

    const issue = {
      id: `jira-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
      userId,
      projectKey: connection.projectKey,
      summary: qualityFinding.summary || `Quality Issue: ${qualityFinding.type}`,
      description: this.formatDescription(qualityFinding),
      issueType: qualityFinding.severity === 'high' ? 'Bug' : 'Task',
      priority: this.mapSeverityToPriority(qualityFinding.severity),
      labels: ['beast-mode', 'quality-check'],
      createdAt: new Date().toISOString(),
      status: 'created'
    };

    this.issues.set(issue.id, issue);
    log.info(`Jira issue created: ${issue.id} for ${userId}`);
    return issue;
  }

  /**
   * Format quality finding as Jira description
   */
  formatDescription(finding) {
    return `*Quality Issue Detected by BEAST MODE*

*Type:* ${finding.type}
*Severity:* ${finding.severity}
*Location:* ${finding.file || 'Unknown'}
*Line:* ${finding.line || 'N/A'}

*Description:*
${finding.message || 'No description provided'}

*Recommendation:*
${finding.recommendation || 'Review and fix'}

---
Generated by BEAST MODE Quality Intelligence`;
  }

  /**
   * Map severity to Jira priority
   */
  mapSeverityToPriority(severity) {
    const mapping = {
      critical: 'Highest',
      high: 'High',
      medium: 'Medium',
      low: 'Low'
    };
    return mapping[severity] || 'Medium';
  }

  /**
   * Get user's issues
   */
  getUserIssues(userId) {
    return Array.from(this.issues.values())
      .filter(issue => issue.userId === userId)
      .sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());
  }
}

// Singleton instance
let jiraInstance = null;

function getJiraIntegration() {
  if (!jiraInstance) {
    jiraInstance = new JiraIntegration();
  }
  return jiraInstance;
}

module.exports = {
  JiraIntegration,
  getJiraIntegration
};
