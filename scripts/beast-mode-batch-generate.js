#!/usr/bin/env node

/**
 * BEAST MODE Batch Generator
 * 
 * Generates multiple features/components at once to demonstrate speed.
 * Can generate 10+ components in seconds.
 */

const fs = require('fs');
const path = require('path');
const { performance } = require('perf_hooks');

const BATCH_SIZE = parseInt(process.argv[2]) || 10;

const FEATURE_TEMPLATES = [
  { name: 'Dashboard', type: 'component', complexity: 'medium' },
  { name: 'Analytics', type: 'component', complexity: 'high' },
  { name: 'Settings', type: 'component', complexity: 'low' },
  { name: 'Reports', type: 'component', complexity: 'medium' },
  { name: 'Notifications', type: 'component', complexity: 'low' },
  { name: 'API', type: 'route', complexity: 'low' },
  { name: 'Webhook', type: 'route', complexity: 'medium' },
  { name: 'Migration', type: 'sql', complexity: 'low' },
  { name: 'Script', type: 'script', complexity: 'medium' },
  { name: 'Test', type: 'test', complexity: 'low' },
];

/**
 * Generate feature based on template
 */
function generateFeature(template, index) {
  const featureName = `${template.name}${index}`;
  const timestamp = new Date().toISOString();
  
  switch (template.type) {
    case 'component':
      return {
        type: 'component',
        name: featureName,
        path: `website/components/beast-mode/${featureName}.tsx`,
        content: generateComponent(featureName, template)
      };
    
    case 'route':
      return {
        type: 'route',
        name: featureName,
        path: `website/app/api/${featureName.toLowerCase()}/route.ts`,
        content: generateAPIRoute(featureName, template)
      };
    
    case 'sql':
      return {
        type: 'migration',
        name: featureName,
        path: `supabase/migrations/${Date.now()}_create_${featureName.toLowerCase()}_table.sql`,
        content: generateMigration(featureName, template)
      };
    
    case 'script':
      return {
        type: 'script',
        name: featureName,
        path: `scripts/${featureName.toLowerCase()}.js`,
        content: generateScript(featureName, template)
      };
    
    case 'test':
      return {
        type: 'test',
        name: featureName,
        path: `tests/${featureName.toLowerCase()}.test.ts`,
        content: generateTest(featureName, template)
      };
    
    default:
      return null;
  }
}

function generateComponent(name, template) {
  return `"use client";

/**
 * ${name} Component
 * Auto-generated by BEAST MODE Batch Generator
 * Complexity: ${template.complexity}
 * Generated: ${new Date().toISOString()}
 */

import React, { useState, useEffect, useCallback, useMemo } from 'react';
import { Card, CardContent, CardHeader, CardTitle } from '../ui/card';

export default function ${name}() {
  const [data, setData] = useState<any[]>([]);
  const [loading, setLoading] = useState(true);

  const loadData = useCallback(async () => {
    try {
      setLoading(true);
      // TODO: Implement data loading
      setData([]);
    } catch (error) {
      console.error('Error loading data:', error);
    } finally {
      setLoading(false);
    }
  }, []);

  useEffect(() => {
    void loadData();
  }, [loadData]);

  if (loading) {
    return <div>Loading...</div>;
  }

  return (
    <div className="w-full max-w-7xl mx-auto p-6">
      <Card>
        <CardHeader>
          <CardTitle>${name}</CardTitle>
        </CardHeader>
        <CardContent>
          <p>${name} component ready for implementation</p>
        </CardContent>
      </Card>
    </div>
  );
}
`;
}

function generateAPIRoute(name, template) {
  return `import { NextRequest, NextResponse } from 'next/server';

/**
 * ${name} API Route
 * Auto-generated by BEAST MODE Batch Generator
 * Generated: ${new Date().toISOString()}
 */
export async function GET(request: NextRequest) {
  try {
    return NextResponse.json({
      success: true,
      data: [],
      message: '${name} API endpoint'
    });
  } catch (error: unknown) {
    return NextResponse.json(
      { error: 'Failed to process request' },
      { status: 500 }
    );
  }
}
`;
}

function generateMigration(name, template) {
  return `-- ${name} Migration
-- Auto-generated by BEAST MODE Batch Generator
-- Generated: ${new Date().toISOString()}

CREATE TABLE IF NOT EXISTS ${name.toLowerCase()} (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_${name.toLowerCase()}_created_at ON ${name.toLowerCase()}(created_at DESC);
`;
}

function generateScript(name, template) {
  return `#!/usr/bin/env node

/**
 * ${name} Script
 * Auto-generated by BEAST MODE Batch Generator
 * Generated: ${new Date().toISOString()}
 */

console.log('${name} script running...');
// TODO: Implement script logic
`;
}

function generateTest(name, template) {
  return `/**
 * ${name} Tests
 * Auto-generated by BEAST MODE Batch Generator
 * Generated: ${new Date().toISOString()}
 */

describe('${name}', () => {
  it('should work', () => {
    expect(true).toBe(true);
  });
});
`;
}

/**
 * Batch generate features
 */
async function batchGenerate() {
  console.log('‚ö° BEAST MODE Batch Generator');
  console.log('='.repeat(60));
  console.log(`üéØ Generating ${BATCH_SIZE} features...\n`);

  const startTime = performance.now();
  const features = [];

  // Generate features
  for (let i = 0; i < BATCH_SIZE; i++) {
    const template = FEATURE_TEMPLATES[i % FEATURE_TEMPLATES.length];
    const feature = generateFeature(template, i);
    if (feature) {
      features.push(feature);
    }
  }

  // Write all files in parallel
  const writePromises = features.map(async (feature) => {
    const fullPath = path.join(__dirname, '..', feature.path);
    await fs.promises.mkdir(path.dirname(fullPath), { recursive: true });
    await fs.promises.writeFile(fullPath, feature.content, 'utf8');
    return feature;
  });

  await Promise.all(writePromises);
  const totalTime = performance.now() - startTime;

  // Statistics
  const totalLines = features.reduce((sum, f) => sum + f.content.split('\n').length, 0);
  const byType = features.reduce((acc, f) => {
    acc[f.type] = (acc[f.type] || 0) + 1;
    return acc;
  }, {});

  console.log('‚úÖ Batch Generation Complete!\n');
  console.log('üìä Results:');
  console.log('-'.repeat(60));
  console.log(`   Total Features: ${features.length}`);
  console.log(`   Total Time: ${totalTime.toFixed(2)}ms (${(totalTime / 1000).toFixed(2)}s)`);
  console.log(`   Total Lines: ${totalLines}`);
  console.log(`   Lines per Second: ${((totalLines / totalTime) * 1000).toFixed(0)}`);
  console.log(`   Features per Second: ${((features.length / totalTime) * 1000).toFixed(2)}`);
  console.log('');

  console.log('üì¶ Generated by Type:');
  Object.entries(byType).forEach(([type, count]) => {
    console.log(`   ${type}: ${count}`);
  });
  console.log('');

  console.log('üìÅ Files Generated:');
  features.slice(0, 10).forEach((f, idx) => {
    console.log(`   ${idx + 1}. ${f.path}`);
  });
  if (features.length > 10) {
    console.log(`   ... and ${features.length - 10} more`);
  }
  console.log('');

  const speedRating = totalTime < 100 ? '‚ö°‚ö°‚ö°' : totalTime < 500 ? '‚ö°‚ö°' : '‚ö°';
  console.log(`üèÜ Speed Rating: ${speedRating}`);
  console.log(`   ${features.length} features in ${(totalTime / 1000).toFixed(2)}s`);
  console.log('');

  return {
    featuresGenerated: features.length,
    totalTime,
    totalLines,
    byType
  };
}

if (require.main === module) {
  batchGenerate().catch(error => {
    console.error('‚ùå Batch generation failed:', error);
    process.exit(1);
  });
}

module.exports = { batchGenerate };
